## grub2
# grub-script port of isodetect.lua from Super Grub2 Disk[1]
# by Ximin Luo; I release this into the public domain.
#
# THIS SCRIPT REQUIRES GRUB2 >= 1.99 TO RUN!!!
#
# isodetect.lua (Jordan Uggla) is based on listisos.lu, bootiso.lua (JustRon[2])
# All of these are released into the public domain.
#
# [1] http://www.supergrubdisk.org/
# [2] http://ubuntuforums.org/showthread.php?t=1288604
#

# TODO submit these feature requests to GRUB, then edit this script to use them:
# - add local variables
# - add setparamnames to create local variables
#

insmod regexp # enable wildcard expansion

#autoscan=yes
#autodetect=yes
#SPLASH=

if [ -z "$LANG" ]; then LANG=us; fi
if [ -z "$isodirs" ]; then isodirs="boot-isos bootisos bootiso iso img"; fi

set color_normal=red/black
set color_highlight=black/red

DEB_LANG_OPTS="keyb=$LANG debian-installer/language=$LANG console-setup/layoutcode?=$LANG"
DEB_KERN_OPTS="noeject noprompt nopersistent"

###############################################################################

# note: loopdev variables are devices *without* the enclosing brackets
# this is because the "loopback" command requires it

#allowed_pattern='^[a-zA-Z0-9_\-\./]*$'  # bug: doesn't work in grub 1.99
allowed_pattern='^[a-zA-Z0-9_./-]+$'
basename_regex='^\([^)]+\)/([^/]+/+)+([^/]+)/*$'
pathname_regex='^\([^)]+\)(.*)$'

# Check that filename contains only allowed characters
function allowed_name # (abspath)
{
	regexp -s 1:REGEXP_RESULT "$pathname_regex" "$1"
	regexp "$allowed_pattern" "$REGEXP_RESULT"
}

# find a file by regexp, store result in RESULT_FIND
function find_file_regexp # (abspath, regexp)
{
	RESULT_FIND=""
	for f in "$1"/*; do
		if ! [ -f "$f" ]; then continue; fi
		if ! regexp "$2" "$f"; then continue; fi
		RESULT_FIND="$f"; break
	done
}

# find a file by wildcard glob, store result in RESULT_FIND
function find_file_glob # (abspath, glob)
{
	RESULT_FIND=""
	for f in "$1"/$2; do
		if ! [ -f "$f" ]; then continue; fi
		RESULT_FIND="$f"; break
	done
}

function basename { regexp -s 2:RESULT_PATH "$basename_regex" "$1"; }
function pathname { regexp -s 1:RESULT_PATH "$pathname_regex" "$1"; }

# Show an error
function error_entry # (abspath, loopdev, message)
{
	menuentry "Unsupported: $1" "$1" "$2" "$3" { shift # needed in grub 1.99
		echo "Error: $3"
		echo ""
		echo -n "The iso file $1 is not supported "
		echo -n "by Super GRUB2 disk. The most likely reason is that the iso is not loop "
		echo -n "bootable. An iso must be specifically designed to read its root "
		echo -n "filesystem from an iso file rather than looking for it in your CDROM "
		echo -n "drive. It is impossible to boot an iso file not specifically designed "
		echo -n "this way with GRUB or any other bootloader."
		echo ""
		echo ""
		echo -n "If you believe that this iso file is loop-bootable it is mounted as "
		echo -n "($2) so you can view its contents in the "
		echo -n "grub shell and try to boot it yourself. If there are any distributions "
		echo -n "that you know are loop bootable but are not currently supported by this "
		echo -n "script please check that you are using the latest version of Super GRUB2 "
		echo -n "Disk then send the commands required to boot the iso to "
		echo -n "supergrub-english@lists.berlios.de so support can be added. Or even " ..
		echo -n "better, convince them to ship a loopback.cfg on their isos:"
		echo ""
		echo ""
		echo "http://www.supergrubdisk.org/wiki/loopback.cfg for more info"
		echo ""
		echo "Press any key to return to the main menu..."
		read
	}
}

# Add a menu entry for a GNU/Linux live system
function linux_entry # (abspath, loopdev, title, linux, initrd, loopkey, params)
{
	# $linux, $initrd should be paths relative to $loopdev

	if ! [ -f "($2)$4" ]; then
		error_entry "$1" "$2" "cannot find linux image $4"
	elif ! [ -f "($2)$5" ]; then
		error_entry "$1" "$2" "cannot find initrd image $5"
	else
		pathname "$1"
		menuentry "$3" "$RESULT_PATH" "$2" "$4" "$5" "$6" "$7" { shift # needed in grub 1.99
			# isoloop=.iso needs to be the last entry, or some stuff (e.g. sysrcd) won't boot
			linux "($2)$3" $6 "$5=$1"
			initrd "($2)$4"
		}
		return 0
	fi

	return 1
}

# Mount the iso file as a loopback device
function mount_iso # (abspath, loopdev)
{
	if ! allowed_name "$1"; then
		menuentry "Error: $1 has unallowed characters" "$allowed_pattern" { shift # needed in grub 1.99
			echo -n "Only alphanumeric characters, periods, underscores, and dashes "
			echo -n "are allowed as part of the filename, for compatibility reasons. "
			echo -n "The exact regex pattern is: $1"
			echo ""
			echo "Press any key to return to the main menu..."
			read
		}
	elif [ -z "$1" ]; then
		error_entry "$1" "$2" "\$abspath is undefined"
	elif ! [ -f "$1" ]; then
		error_entry "$1" "$2" "Cannot find isofile $1"
	else
		if loopback "$2" "$1"; then return 0; fi
		# TODO once it's possible to capture command output, use that instead
		# of generic error message
		error_entry "$1" "$2" "Cannot load ISO: loopback init error"
	fi
	return 1
}

# Detect the live system type and boots it
# Must not be called recursively # TODO (put in a guard for this)
function iso_detect # (abspath)
{
	# Pick a device name that's the same name as the iso
	basename "$1"; _iso_detect__loopdev="$RESULT_PATH"
	# Linux shouldn't be passed the grub device name, just the relative path
	pathname "$1"; _iso_detect__relpath="$RESULT_PATH"

	if ! mount_iso "$1" "$_iso_detect__loopdev"; then return 1; fi

	# Any distro providing a loopback.cfg
	_iso_detect__loopcfg=""
	for path in "/boot/grub/loopback.cfg" "/grub/loopback.cfg"; do
		if [ -f "($_iso_detect__loopdev)$path" ]; then
			_iso_detect__loopcfg="$path"
			break
		fi
	done

	iso_detect_inner "$1" "$_iso_detect__loopdev" "$_iso_detect__relpath" "$_iso_detect__loopcfg"
}

function iso_detect_inner # (abspath, loopdev, relpath, loopcfg)
{
	if [ -n "$4" ]; then
		menuentry "Recursive Boot: $1" "$2" "$3" "$4" { shift # needed in grub 1.99
			set root="($1)"
			set iso_path="$2"
			export iso_path
			configfile "$3"
		}
		return 0

	elif [ "$autodetect" == "no" ]; then
		error_entry "$1" "$2" "Unsupported ISO type"
		return 1

	# auto-detect section. entries marked #? have not yet been tested

	elif [ -d "($2)/casper" ]; then
		# casper-based distros, e.g. ubuntu, backtrack
		for img_dir in casper boot; do
			if ! [ -f "($2)/$img_dir/vmlinuz" ]; then continue; fi
			find_file_glob "($2)/$img_dir" 'initrd*.*z'; pathname "$RESULT_FIND"
			linux_entry "$1" "$2" "Boot casper: $1" "/$img_dir/vmlinuz" "$RESULT_PATH" "iso-scan/filename" "boot=casper $DEB_KERN_OPTS $SPLASH $DEB_LANG_OPTS"
			return 0
		done

	elif [ -f "($2)/debian" ]; then
		# debian-based distros
		# note that as of this writing, debian install discs can't fully handle loop-boot
		# the installation may complain about "could not find CD-ROM" and you'll need to mount it manually
		for img_dir in "($2)/install".*; do
			if ! [ -f "$img_dir/vmlinuz" ]; then continue; fi
			pathname "$img_dir"
			linux_entry "$1" "$2" "Boot debian: $1" "$RESULT_PATH/vmlinuz" "$RESULT_PATH/initrd.gz" "iso-scan/filename" "$DEB_KERN_OPTS $SPLASH $DEB_LANG_OPTS"
			return 0
		done

	elif [ -f "($2)/sysrcd.dat" ]; then
		# system rescue cd
		linux_entry "$1" "$2" "Boot sysrcd: $1" "/isolinux/rescuecd" "/isolinux/initram.igz" "isoloop" "root=/dev/ram"
		return 0

	elif [ -d "($2)/KNOPPIX" ]; then
		# KNOPPIX
		linux_entry "$1" "$2" "Boot KNOPPIX: $1" "/boot/isolinux/linux" "/boot/isolinux/minirt.gz" "bootfrom" "BOOT_IMAGE=knoppix"
		return 0

	elif [ -d "($2)/pmagic" ]; then
		#? pmagic
		linux_entry "$1" "$2" "Boot pmagic: $1" "/pmagic/bzImage" "/pmagic/initramfs" "iso_filename" "edd=off noapic load_ramdisk=1 prompt_ramdisk=0 rw sleep=10 loglevel=0 keymap=$LANG"
		return 0

	elif [ -d "($2)/sidux" ]; then
		# sidux
		false # not yet supported
		# sidux uses some complicated-ass naming system for its linux/initrd files.
		# it is possible to detect them, but i haven't yet bothered to code this.

	elif [ -d "($2)/slax" ]; then
		#? slax
		linux_entry "$1" "$2" "Boot slax: $1" "/boot/vmlinuz" "/boot/initrd.gz" "from" "ramdisk_size=6666 root=/dev/ram0 rw"
		return 0

	elif [ -f "($2)/boot/tinycore.gz" ]; then
		#? tinycore. isoloop isn't actually used but we need that param to be non-empty
		linux_entry "$1" "$2" "Boot tinycore: $1" "/boot/bzImage" "/boot/tinycore.gz" "isoloop" ""
		return 0

	elif [ -f "($2)/boot/grub/grub.cfg" ]; then
		find_file_glob "($2)/boot/grub" '*detect*'
		if [ -n "$RESULT_FIND" ]; then
			# super grub2 disk
			menuentry "Recursive Boot SG2D: $1" "$2" { shift # needed in grub 1.99
				set root="($1)"
				configfile "/boot/grub/grub.cfg"
			}
			return 0
		fi
	fi

	error_entry "$1" "$2" "Unsupported ISO type"
	return 1
}

function verify_checksum # (iso_dir, sum_file, sum_cmd)
{
	if ! [ -f "$1/$2" ]; then return; fi

	menuentry --class="checksum" "Verify $2 in $1" "$1" "$2" "$3" { shift # needed in grub 1.99
		echo "Verifying $1/$2..."
		$3 -c "$1/$2" -p "$1"
	}
}

function iso_scandir # (iso_dir)
{
	for _iso_scandir__iso in "$1"/*.iso; do
		if ! [ -e "$_iso_scandir__iso" ]; then continue; fi
		if ! iso_detect "$_iso_scandir__iso"; then continue; fi
		SCAN_FOUND_ISO=true
	done
	verify_checksum "$1" MD5SUMS md5sum
	verify_checksum "$1" SHA1SUMS sha1sum
	verify_checksum "$1" SHA256SUMS sha256sum
}

# Scan all devices
function iso_scanall # (isodirs)
{
	SCAN_FOUND_ISO=false
	menuentry " " { true; }

	for device in (*); do
		for path in "$device/" "$device/boot/"; do
			for subdir in "$@"; do
				if ! [ -d "$path$subdir" ]; then continue; fi
				iso_scandir "$path$subdir"
			done
		done
	done

	if $SCAN_FOUND_ISO; then return 0; fi

	echo -n "Error: No iso files were found in the [$isodirs] subdirectories of "
	echo -n "/ and /boot/ of any device. To search inside different directories, "
	echo -n "set the environment variable isodirs. "
	echo ""
	echo ""
	echo -n "To switch off auto-detection, set autoscan=no. The function iso_scanall "
	echo -n "can be called with a list of directories as its parameters. "
	echo ""
	return 1
}

menuentry --class="meta" "Rescan all devices" $isodirs { shift # needed in grub 1.99
	iso_scanall "$@"
}

if [ "$autoscan" != "no" ]; then
	if ! iso_scanall $isodirs; then read; fi
fi
