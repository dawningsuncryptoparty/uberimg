## grub2
# grub-script port of isodetect.lua from Super Grub2 Disk[1]
# by Ximin Luo; I release this into the public domain.
#
# THIS SCRIPT REQUIRES GRUB2 >= 1.99 TO RUN!!!
#
# isodetect.lua (Jordan Uggla) is based on listisos.lu, bootiso.lua (JustRon[2])
# All of these are released into the public domain.
#
# [1] http://www.supergrubdisk.org/
# [2] http://ubuntuforums.org/showthread.php?t=1288604
#

# TODO submit these feature requests to GRUB, then edit this script to use them:
# - add local variables
# - add setparamnames to create local variables
#

insmod regexp # enable wildcard expansion

# auto-scan medium for ISOs upon boot? (default: yes)
# if no, you need to drop to GRUB2 shell and run iso_scanall manually
#AUTOSCAN=yes

# auto-detect non-standard recursive-boot layouts? (default: yes)
#AUTODETECT=no

if [ -z "$LANG" ]; then LANG=us; fi
if [ -z "$IMG_DIR" ]; then IMG_DIR="img"; fi

LINUX_DIR=linux
INITRD_DIR=initrd

set color_normal=red/black
set color_highlight=black/red

DEB_LANG_OPTS="keyb=$LANG debian-installer/language=$LANG console-setup/layoutcode?=$LANG"
DEB_KERN_OPTS="noeject noprompt nopersistent"
SPLASH=""

###############################################################################

# note: loopdev variables are devices *without* the enclosing brackets
# this is because the "loopback" command requires it

function pause # ()
{
	echo "Press any key to return to the main menu..."
	read
}

# find a file by regexp, store result in RESULT_FIND
function find_file_regexp # (abspath, regexp)
{
	RESULT_FIND=""
	for f in "$1"/*; do
		if ! [ -f "$f" ]; then continue; fi
		if ! regexp "$2" "$f"; then continue; fi
		RESULT_FIND="$f"; return 0
	done
	return 1
}

# find a file by wildcard glob, store result in RESULT_FIND
function find_file_glob # (abspath, glob)
{
	RESULT_FIND=""
	for f in "$1"/$2; do
		if ! [ -f "$f" ]; then continue; fi
		RESULT_FIND="$f"; return 0
	done
	return 1
}

#__allowed_pattern='^[a-zA-Z0-9_\-\.]*$'  # bug: doesn't work in grub 1.99
__allowed_pattern='^[a-zA-Z0-9_.-]+$'
__mainname_regex='^(.+)\.[^.]*$|^([^.]*)$'
__basename_regex='^\([^)]+\)/([^/]+/+)+([^/]+)/*$'
__pathname_regex='^\([^)]+\)(.*)$'

function mainname { regexp -s 1:_1 -s 2:_2 "$__mainname_regex" "$1"; RESULT_PATH="$_1$_2"; }
function basename { regexp -s 2:RESULT_PATH "$__basename_regex" "$1"; }
function pathname { regexp -s 1:RESULT_PATH "$__pathname_regex" "$1"; }
# Check that filename contains only allowed characters
function allowed_name { regexp "$__allowed_pattern" "$1"; }

# Show an error
function error_entry # (abspath, loopdev, message)
{
	menuentry "Unsupported: $1" "$1" "$2" "$3" { shift # needed in grub 1.99
		echo "Error: $3"
		echo ""
		echo -n "The iso file $1 is not supported "
		echo -n "by Super GRUB2 disk. The most likely reason is that the iso is not loop "
		echo -n "bootable. An iso must be specifically designed to read its root "
		echo -n "filesystem from an iso file rather than looking for it in your CDROM "
		echo -n "drive. It is impossible to boot an iso file not specifically designed "
		echo -n "this way with GRUB or any other bootloader."
		echo ""
		echo ""
		echo -n "If you believe that this iso file is loop-bootable it is mounted as "
		echo -n "($2) so you can view its contents in the "
		echo -n "grub shell and try to boot it yourself. If there are any distributions "
		echo -n "that you know are loop bootable but are not currently supported by this "
		echo -n "script please check that you are using the latest version of Super GRUB2 "
		echo -n "Disk then send the commands required to boot the iso to "
		echo -n "supergrub-english@lists.berlios.de so support can be added. Or even " ..
		echo -n "better, convince them to ship a loopback.cfg on their isos:"
		echo ""
		echo ""
		echo "http://www.supergrubdisk.org/wiki/loopback.cfg for more info"
		echo ""
		pause
	}
}

# Add a menu entry for a GNU/Linux live system
function linux_entry # (abspath, loopdev, title, linux, initrd, loopkey, params)
{
	# $linux, $initrd should be paths relative to $loopdev
	# we also check for user overrides for the linux and initrd images
	# $_CUR_SCANDIR is set by iso_scandir

	_linux_entry__linux=""
	if find_file_glob "$_CUR_SCANDIR_$LINUX_DIR" "$2"'.*'; then
		_linux_entry__linux="$RESULT_FIND"
	elif find_file_glob "($2)" "$4"; then
		_linux_entry__linux="$RESULT_FIND"
	fi

	_linux_entry__initrd=""
	if find_file_glob "$_CUR_SCANDIR_$INITRD_DIR" "$2"'.*'; then
		_linux_entry__initrd="$RESULT_FIND"
	elif find_file_glob "($2)" "$5"; then
		_linux_entry__initrd="$RESULT_FIND"
	fi

	if [ -z "$_linux_entry__linux" ]; then
		error_entry "$1" "$2" "cannot find linux image ($2)/$4 or $_CUR_SCANDIR_$LINUX_DIR/$2.*"
		return 1
	fi

	if [ -z "$_linux_entry__initrd" ]; then
		error_entry "$1" "$2" "cannot find initrd image ($2)/$5 or $_CUR_SCANDIR_$INITRD_DIR/$2.*"
		return 1
	fi

	pathname "$1"
	menuentry "$3" "$RESULT_PATH" "$_linux_entry__linux" "$_linux_entry__initrd" "$6" "$7" { shift # needed in grub 1.99
		# isoloop=.iso needs to be the last entry, or some stuff (e.g. sysrcd) won't boot
		linux "$2" $5 "$4=$1"
		initrd "$3"
	}
	return 0
}

# Mount the iso file as a loopback device
function mount_iso # (abspath, loopdev)
{
	if ! allowed_name "$2"; then
		menuentry "Error: $1 has unallowed characters" "$2" { shift # needed in grub 1.99
			echo -n "Only alphanumeric characters, periods, underscores, and dashes "
			echo -n "are allowed as part of the filename, for compatibility reasons. "
			echo ""
			echo "The exact regex pattern is: $__allowed_pattern"
			echo "The failing string is: $1"
			echo ""
			pause
		}
	elif [ -z "$1" ]; then
		error_entry "$1" "$2" "\$abspath is undefined"
	elif ! [ -f "$1" ]; then
		error_entry "$1" "$2" "Cannot find image file $1"
	else
		if loopback "$2" "$1"; then return 0; fi
		# TODO once it's possible to capture command output, use that instead
		# of generic error message
		error_entry "$1" "$2" "Cannot load ISO: loopback init error"
	fi
	return 1
}

# Detect the live system type and boots it
# Must not be called recursively # TODO (put in a guard for this)
function iso_detect # (abspath)
{
	# Pick a device name that's the same name as the iso
	basename "$1"; mainname "$RESULT_PATH"; _iso_detect__loopdev="$RESULT_PATH"
	# Linux shouldn't be passed the grub device name, just the relative path
	pathname "$1"; _iso_detect__relpath="$RESULT_PATH"

	if ! mount_iso "$1" "$_iso_detect__loopdev"; then return 1; fi

	# Any distro providing a loopback.cfg
	_iso_detect__loopcfg=""
	for path in "/boot/grub/loopback.cfg" "/grub/loopback.cfg"; do
		if [ -f "($_iso_detect__loopdev)$path" ]; then
			_iso_detect__loopcfg="$path"
			break
		fi
	done

	iso_detect_inner "$1" "$_iso_detect__loopdev" "$_iso_detect__relpath" "$_iso_detect__loopcfg"
}

function iso_detect_inner # (abspath, loopdev, relpath, loopcfg)
{
	if [ -n "$4" ]; then
		menuentry "Recursive Boot: $1" "$2" "$3" "$4" { shift # needed in grub 1.99
			set root="($1)"
			set iso_path="$2"
			export iso_path
			configfile "$3"
		}
		return 0

	elif [ "$AUTODETECT" == "no" ]; then
		error_entry "$1" "$2" "Unsupported ISO type"
		return 1

	# auto-detect section. entries marked #? have not yet been tested

	elif [ -d "($2)/casper" ]; then
		# casper-based distros, e.g. ubuntu, backtrack
		linux_entry "$1" "$2" "Boot casper: $1" 'casper/vmlinuz' 'casper/initrd*.*z' "iso-scan/filename" "boot=casper $DEB_KERN_OPTS $SPLASH $DEB_LANG_OPTS"
		return 0

	elif [ -f "($2)/debian" ]; then
		# debian-based distros
		# note that as of this writing, debian install discs can't fully handle loop-boot
		# the installation may complain about "could not find CD-ROM" and you'll need to mount it manually
		linux_entry "$1" "$2" "Boot debian: $1" 'install.*/vmlinuz' 'install.*/initrd.gz' "iso-scan/filename" "$DEB_KERN_OPTS $SPLASH $DEB_LANG_OPTS"
		return 0

	elif [ -f "($2)/sysrcd.dat" ]; then
		# system rescue cd
		linux_entry "$1" "$2" "Boot sysrcd: $1" 'isolinux/rescuecd' 'isolinux/initram.igz' "isoloop" "root=/dev/ram"
		return 0

	elif [ -d "($2)/KNOPPIX" ]; then
		# KNOPPIX
		linux_entry "$1" "$2" "Boot KNOPPIX: $1" 'boot/isolinux/linux' 'boot/isolinux/minirt.gz' "bootfrom" "BOOT_IMAGE=knoppix"
		return 0

	elif [ -d "($2)/aptosid" ]; then
		# aptosid (was sidux)
		linux_entry "$1" "$2" "Boot aptosid: $1" 'boot/vmlinuz*.*' 'boot/initrd*.*' "fromiso" "boot=fll"
		return 0

	elif [ -d "($2)/slax" ]; then
		# slax
		linux_entry "$1" "$2" "Boot slax: $1" 'boot/vmlinuz' 'boot/initrd.gz' "from" "ramdisk_size=6666 root=/dev/ram0 rw"
		return 0

	elif [ -d "($2)/live" ]; then
		# generic, possibly TAILS
		# currently not working due to https://tails.boum.org/bugs/fromiso_implemented_incorrectly/
		linux_entry "$1" "$2" "Boot generic/TAILS: $1" 'live/vmlinuz' 'live/initrd.*' "fromiso" "boot=live config noswap live-media=removable nopersistent noprompt block.events_dfl_poll_msecs=1000 $SPLASH"
		return 0

	elif [ -d "($2)/pmagic" ]; then
		#? pmagic
		linux_entry "$1" "$2" "Boot pmagic: $1" 'pmagic/bzImage' 'pmagic/initramfs' "iso_filename" "edd=off noapic load_ramdisk=1 prompt_ramdisk=0 rw sleep=10 loglevel=0 keymap=$LANG"
		return 0

	elif [ -f "($2)/boot/tinycore.gz" ]; then
		#? tinycore. isoloop isn't actually used but we need that param to be non-empty
		linux_entry "$1" "$2" "Boot tinycore: $1" 'boot/bzImage' 'boot/tinycore.gz' "isoloop" ""
		return 0

	elif [ -f "($2)/boot/gnumach" ]; then
		#? arch hurd, don't think I ever tested this
		menuentry "Boot Arch Hurd: $1" "$2" { shift # needed in grub 1.99
			set root="($1)"
			multiboot /boot/gnumach root=device:"$1"
			module /hurd/iso9660fs.static --multiboot-command-line='${kernel-command-line}' --host-priv-port='${host-port}' --device-master-port='${device-port}' --exec-server-task='${exec-task}' -T typed '${root}' '$(task-create)' '$(task-resume)'
			module /lib/ld-2.11.90.so /hurd/exec '$(exec-task=task-create)'
		}
		return 0

	elif [ -f "($2)/boot/grub/grub.cfg" ]; then
		if ! find_file_glob "($2)/boot/grub" '*supergrub*'; then continue; fi
		# super grub2 disk
		menuentry "Recursive Boot SG2D: $1" "$2" { shift # needed in grub 1.99
			set root="($1)"
			configfile "/boot/grub/grub.cfg"
		}
		return 0
	fi

	error_entry "$1" "$2" "Unsupported ISO type"
	return 1
}

function verify_checksum # (iso_dir, sum_file, sum_cmd)
{
	if ! [ -f "$1/$2" ]; then return; fi

	menuentry --class="checksum" "Verify $2 in $1" "$1" "$2" "$3" { shift # needed in grub 1.99
		cat "$1/$2"
		echo "Verifying $1/$2..."
		$3 -k -c "$1/$2" -p "$1"
		pause
	}
}

function iso_scandir # (boot_dir/)
{
	_CUR_SCANDIR_="$1"
	for _iso_scandir__iso in "$1$IMG_DIR"/*.iso; do
		if ! [ -e "$_iso_scandir__iso" ]; then continue; fi
		if ! iso_detect "$_iso_scandir__iso"; then continue; fi
		SCAN_FOUND_ISO=true
	done
	verify_checksum "$1$IMG_DIR" MD5SUMS md5sum
	verify_checksum "$1$IMG_DIR" SHA1SUMS sha1sum
	verify_checksum "$1$IMG_DIR" SHA256SUMS sha256sum
}

# Scan all devices
function iso_scanall
{
	echo "Scanning for bootable ISOs in all devices. This may take a while..."
	SCAN_FOUND_ISO=false
	menuentry " " { true; }

	for _iso_scanall__device in (*); do
		for _iso_scanall__path in "$_iso_scanall__device/" "$_iso_scanall__device/boot/"; do
			if ! [ -d "$_iso_scanall__path$IMG_DIR" ]; then continue; fi
			iso_scandir "$_iso_scanall__path"
		done
	done

	if $SCAN_FOUND_ISO; then return 0; fi

	echo -n "Error: No iso files were found in the /$1 or /boot/$1 directories of "
	echo -n "any device. To search inside different directories, set the IMG_DIR "
	echo -n "environment variable, then call iso_scanall. "
	echo ""
	echo -n "To switch off auto-detection, set AUTOSCAN=no. "
	echo ""
	pause
	return 1
}

menuentry --class="meta" "Rescan all devices" { shift # needed in grub 1.99
	iso_scanall
}

if [ "$AUTOSCAN" != "no" ]; then
	iso_scanall
fi
